name: 'Run Ruby Test Suite'
description: 'Complete Ruby test suite with environment setup'
inputs:
  ruby-version:
    description: 'Ruby version to use'
    default: '3.2'
    required: false
  verbose:
    description: 'Run tests in verbose mode'
    default: 'true'
    required: false
  suites:
    description: 'Test suites to run: all, core, deployment, quality'
    default: 'core,quality'
    required: false
  skip-docker:
    description: 'Skip Docker-related tests'
    default: 'true'
    required: false
  skip-remote:
    description: 'Skip remote installation tests (for CI environments)'
    default: 'false'
    required: false

runs:
  using: composite
  steps:
    - name: Setup Ruby Environment
      uses: ./.github/actions/setup-ruby
      with:
        ruby-version: ${{ inputs.ruby-version }}
    
    - name: Set PAGES_REPO_NWO for Jekyll builds
      shell: bash
      run: |
        # Set PAGES_REPO_NWO for jekyll-github-metadata gem
        echo "PAGES_REPO_NWO=bamr87/zer0-mistakes" >> $GITHUB_ENV
    
    - name: Run Test Suite
      shell: bash
      run: |
        chmod +x ./test/test_runner.sh
        
        ARGS=""
        if [[ "${{ inputs.verbose }}" == "true" ]]; then
          ARGS="$ARGS --verbose"
        fi
        if [[ "${{ inputs.skip-docker }}" == "true" ]]; then
          ARGS="$ARGS --skip-docker"
        fi
        if [[ "${{ inputs.skip-remote }}" == "true" ]]; then
          ARGS="$ARGS --skip-remote"
        fi
        if [[ -n "${{ inputs.suites }}" ]]; then
          ARGS="$ARGS --suites ${{ inputs.suites }}"
        fi
        
        ./test/test_runner.sh $ARGS
    
    - name: Validate Test Results
      shell: bash
      run: |
        # Check for test results - the test_runner creates files in test/results/ and test/reports/
        RESULTS_DIR="./test/results"
        REPORTS_DIR="./test/reports"
        
        # Check if any result files were created
        if [[ ! -d "$RESULTS_DIR" ]] || [[ -z "$(ls -A $RESULTS_DIR 2>/dev/null)" ]]; then
          # Also check for reports directory
          if [[ ! -d "$REPORTS_DIR" ]] || [[ -z "$(ls -A $REPORTS_DIR 2>/dev/null)" ]]; then
            echo "::warning::No test results found in $RESULTS_DIR or $REPORTS_DIR"
            exit 1
          fi
        fi
        
        # Check for JSON result files - look for failure indicators
        FAILED=false
        shopt -s nullglob
        for result_file in "$RESULTS_DIR"/*.json "$REPORTS_DIR"/*.json; do
          if [[ -f "$result_file" ]]; then
            # Check for failed status in JSON (case-insensitive)
            if grep -qiE '"status":\s*"failed"|"result":\s*"fail"' "$result_file" 2>/dev/null; then
              echo "::error::Test failures found in $result_file"
              cat "$result_file"
              FAILED=true
            fi
          fi
        done
        shopt -u nullglob
        
        # Also check text reports for actual failure indicators
        # Note: "Failed: 0" in summary should NOT trigger failure - only actual test failures
        shopt -s nullglob
        for report_file in "$REPORTS_DIR"/*.txt; do
          if [[ -f "$report_file" ]]; then
            # Check for failure patterns that indicate actual test failures, not summary lines
            # Exclude lines like "Failed: 0" which indicate no failures
            if grep -qiE '(FAILED|FAILURE)' "$report_file" 2>/dev/null && \
               ! grep -qE 'Failed:\s*0' "$report_file" 2>/dev/null; then
              # Double-check: look for non-zero failure count
              if grep -qE 'Failed:\s*[1-9]' "$report_file" 2>/dev/null || \
                 grep -qiE '\[FAIL\]|\bFAILED\b.*test' "$report_file" 2>/dev/null; then
                echo "::error::Test failures found in $report_file"
                cat "$report_file"
                FAILED=true
              fi
            fi
          fi
        done
        shopt -u nullglob
        
        if [[ "$FAILED" == "true" ]]; then
          exit 1
        fi
        
        echo "::notice::All tests passed successfully"